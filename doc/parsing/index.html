<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>delSAT API  - parsing</title><meta content="delSAT API - parsing" name="description"/><meta content="delSAT API parsing" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.min.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title">delSAT API<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 current" name="_root_.parsing" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="parsing"></a><a id="parsing:parsing"></a> <span class="permalink"><a href="../parsing/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">parsing</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="DisjunctiveAnswerSetProgramWithCosts.html" title="An ASP ground program" class="class"></a><a href="DisjunctiveAnswerSetProgramWithCosts.html" title="An ASP ground program">DisjunctiveAnswerSetProgramWithCosts</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="GroundSymbolicASPRule.html" title="As SymbolicASPGroundRule, but without variables" class="class"></a><a href="GroundSymbolicASPRule.html" title="As SymbolicASPGroundRule, but without variables">GroundSymbolicASPRule</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="SymbolicASPRule.html" title="This data type can be used to represent all fundamental rule types in Answer Set Programming except weak rules :~." class="class"></a><a href="SymbolicASPRule.html" title="This data type can be used to represent all fundamental rule types in Answer Set Programming except weak rules :~.">SymbolicASPRule</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><h1>parsing<span class="permalink"><a href="../parsing/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">parsing</span></span></h4><div id="comment" class="fullcommenttop"></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="input.ProbabilisticAnswerSetProgram" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="DisjunctiveAnswerSetProgramWithCostsextendsProductwithSerializable"></a><a id="DisjunctiveAnswerSetProgramWithCosts:DisjunctiveAnswerSetProgramWithCosts"></a> <span class="permalink"><a href="../parsing/DisjunctiveAnswerSetProgramWithCosts.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="DisjunctiveAnswerSetProgramWithCosts.html" title="An ASP ground program"><span class="name">DisjunctiveAnswerSetProgramWithCosts</span></a><span class="params">(<span name="groundSymbolicASPRules">groundSymbolicASPRules: <span name="scala.collection.Set" class="extype">Set</span>[<a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">GroundSymbolicASPRule</a>]</span>, <span name="backgroundProgramAspifOpt">backgroundProgramAspifOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">An ASP ground program
</p><div class="fullcomment"><div class="comment cmt"><p>An ASP ground program
</p></div><dl class="paramcmts block"><dt class="param">groundSymbolicASPRules</dt><dd class="cmt"><p>Set of ground rules. If backgroundProgramAspifOpt is defined, the symbolicASPRules added to the rules obtained by parsing the string in backgroundProgramAspifOpt</p></dd><dt class="param">backgroundProgramAspifOpt</dt><dd class="cmt"><p>Aspif format with optional costs and parameter specs</p></dd></dl></div></li><li class="indented0 " name="input.GroundSymbolicASPRule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="GroundSymbolicASPRuleextendsProductwithSerializable"></a><a id="GroundSymbolicASPRule:GroundSymbolicASPRule"></a> <span class="permalink"><a href="../parsing/GroundSymbolicASPRule.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="GroundSymbolicASPRule.html" title="As SymbolicASPGroundRule, but without variables"><span class="name">GroundSymbolicASPRule</span></a><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="aspIOutils.Pred" class="extype">Pred</span>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">As SymbolicASPGroundRule, but without variables
</p><div class="fullcomment"><div class="comment cmt"><p>As SymbolicASPGroundRule, but without variables
</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights used elsewhere)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt; p &lt; 1 or -1 (see above)</p></dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SymbolicASPRuleextendsProductwithSerializable"></a><a id="SymbolicASPRule:SymbolicASPRule"></a> <span class="permalink"><a href="../parsing/SymbolicASPRule.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="SymbolicASPRule.html" title="This data type can be used to represent all fundamental rule types in Answer Set Programming except weak rules :~."><span class="name">SymbolicASPRule</span></a><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<span name="aspIOutils.Pred" class="extype">Pred</span>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="aspIOutils.Pred" class="extype">Pred</span>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>, <span name="variableBindings">variableBindings: <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>)] = <span class="symbol">Seq()</span></span>, <span name="domainAtoms">domainAtoms: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Seq()</span></span>, <span name="distrPrOverGroundings">distrPrOverGroundings: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">This data type can be used to represent all fundamental rule types in Answer Set Programming except weak rules :~.</p><div class="fullcomment"><div class="comment cmt"><p>This data type can be used to represent all fundamental rule types in Answer Set Programming except weak rules :~.
Additionally, it supports probabilistic rules (rules with a probabilistic weight).
More complex ASP rule types can be created as combinations or desugarings using these basic types, see ASP literature (e.g., Lifschitz'99).
This data type fully supports ground rules but also has limited support for non-ground rules (for more advanced grounding
needs, it is recommended to use delSAT with an aspif file produced from the non-ground answer set program with a tool such as clingo).</p><p>This class also provides some support for non-ground rules, using parameter variableDomains. However, for
more complex grounding requirements, the answer set program should be translated into aspif format before calling delSAT,
using, e.g., clingo.</p><p>Default (non-monotonic) and classical negation:
To represent a classically ("strong") negated atom a, write -p(a). Allowed in head and body literals. "--p(a)" is not allowed.
To represent default negation in head or body literals, use prefix "not" (e.g., "not p(a)").
Double negation ("not not ") is also allowed, both in head and body literals. Triple negation ("not not not") is not supported.</p><p>Redundant whitespace in literals is not allowed. There must be exactly one space character after a "not" and there
mustn't be any whitespaces in literals except to separate "not".
E.g., "not f(X)" is ok, "  not  f (X) " is invalid.</p><p>Supported answer set rule types:</p><p>Integrity constraints:
These are simply rules where the head is the empty set.</p><p>"Weight rules" (ASP terminology. Unrelated to rules with probabilistic weights!):
Instead of bodyLiterals there can be a weightBodySymbolicOpt in the form of Some(lowerBound, Seq((weight1, literal1), ..., (weightN, literalN)))
literal can here be "atom" or "not atom" (but not "not not atom"). Observe that more complex weight rules (e.g.,
with upper bound) can be desugared into multiple more basic rules.
If weightBodySymbolicOpt is defined, bodyLiterals must be empty (but rules with both weight aggregates and plain literals can
be created as combinations of more basic rules).</p><p>Choice rules:
Instead of headLiterals, choiceHeadOpt can be present in form of Some(Seq(literal1, ..., literalN)), where
each literal can here be an "atom" (but not "not atom" or "not not atom"). Again, more complex rules (such as choice in bodies)
can be expressed as combinations of simpler rules.
Choice rules are often preferable in terms of complexity over disjunctions (i.e., more than one literal) in the head,
but observe that their semantics is different.
If choiceHeadOpt is defined, headLiterals must be empty.</p><p>Probabilistic rules:</p><p>To express probabilistic facts, use special predicates _pr_ and _cost_ (must be facts, i.e., in head, with empty body).
E.g., "_pr_(heads(coin), 5000)" or  "_cost_(1 - f(coin))".</p><p>To attach a probability to an entire normal rule, you can use probabilityOpt. In this case, the rule must be normal, i.e,
have exactly one head literal which is positive and double negation or a weight body in the body aren't allowed.</p><p>A probability is represented as a double number w, 0&lt;=w&lt;=1.</p><p>Probabilistic rules don't have to be probabilistically independent from each other.</p><p>If the probabilityOpt=Some(-1), the probability is unknown (informally meaning 'rule v not rule', i.e., a
so-called _spanning rule_ [Nickles,Mileo 2015]).</p><p>Grounding:</p><p>There is limited support for grounding (for a more powerful approach to grounding, use clingo/gringo or some
other modern ASP grounder to generate an aspif file which you can then use directly with delSAT):</p><p>Grounding is performed if variableBindings and/or variableDomains are provided.</p><p>variableBindings are processed linearly. E.g., rule r(X,Y) :- q(X), p(Y) with variableBindings Seq((X,"a"),(Y,"b"),(X,"c"))
results in a single ground rule r(a,b) :- q(a), p(b), because the second binding of X is ignored. To explore
all combinations, use something like concurrentBindings.flatMap(bindings -&gt; SymbolicASPRule(...,bindings,...))</p><p>In contrast to variableBindings, domainAtoms are processed by using all possible combinations.
E.g., r(X,Y) :- q(X), p(Y) with domainAtoms Seq("q(a)", "p(b)", "q(c)") results in two ground rules
r(a,b) :- q(a), p(b) and r(c,b) :- q(c), p(b)</p><p>variableBindings are processed before domainAtoms, so if any variable is already bound by variableBindings,
it cannot be re-bound by any domainAtoms.</p><p>domainAtoms (as a parameter of SymbolicASPRule) are not necessarily actually facts (in the logical sense) and they are
not automatically added as literals to the rule. If you want that, you need to add those "facts" explictly to
the bodyLiterals or make them actual facts as rules of their own.</p><p>Approaches (outside the scope of delSAT) to obtain domainAtoms could be, e.g., to deduce them as extension from given
ground rules where the involved predicates don't recursively depend on each other (as in lparse 1.0), or - less powerful -
to simply use all given ground facts (ground rules with empty body), or to use ground atoms in the body of the non-ground rule.</p><p>If a probability w is provided for a non-ground normal rule using probabilityOpt, it refers either to the conjunction of the
ground rules generated from the non-ground rule or to each individual ground rule, depending on distrPrOverGroundings.
E.g., with distrPrOverGroundings=false, Pr[p(X):-q(Y)] = w is equivalent to Pr[(p(a):-q(b)) <sup> (p(c):-q(a)) </sup> ...] = w,
if the ground instances of p(X):-q(Y) are p(a):-q(b), p(c):-q(a), ...
Whereas with distrPrOverGroundings=true, Pr[p(X):-q(Y)] = w is equivalent to Pr[p(a):-q(b)]=w <sup> Pr[p(c):-q(a)]=w </sup> ...</p><p>ASP variables are words consisting of characters and digits which start with an uppercase letter.
Variables can occur in any literals in the head and/or body.</p><p>Observe that gringo-style anonymous variables (_) or character ' in variables are not allowed here (but such variables
can be used when using clingo/gringo output with delSAT).</p><p>Variables in terms are recognized up to parantheses nesting level three.</p><p>delSAT doesn't distinguish between the case that a variable occurs in the head and the case it occurs in the body.
</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights!)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt;= p &lt;= 1 or -1 (see above)</p></dd><dt class="param">variableBindings</dt><dd class="cmt"><p>A list containing variable names (words starting with an uppercase letter) paired with ground terms.
                             For example, Seq(("X", "a1"), ("X", "a2"), ("Y", "b1"), ...).
                             Alternatively or additioally, domainAtoms can be provided to ground rules.</p></dd><dt class="param">domainAtoms</dt><dd class="cmt"><p>A list of ground facts, e.g., "fac1(a,b)", "fac1(c,d)", "fac2(a)", ...).
                             Like variableBindings, they are used to ground rules (by determining further variable bindings).
                             NB: Ground facts listed here serve only to instantiate variables, they do not automatically become
                             body literals or even global facts. If you wish to add them, e.g., to the rule body, you need to append them
                             to bodyLiterals.</p></dd><dt class="param">distrPrOverGroundings</dt><dd class="cmt"><p>If true (default), the probability probabilityOpt (if defined) is assumed to be the probability of each individual
                             ground instances of the rule (corresponding to weight syntax <span name="pr" class="extype">pr</span> in PrASP).
                             If false, the given probability (probabilityOpt, if defined) is the probability of the
                             entire conjunction of all ground instances of this rule (corresponding to weight syntax [pr] in PrASP).
                             Only relevant if there are variables in the literals, variableDomains is not empty, and probabilityOpt is defined.</p></dd></dl></div></li></ol></div></div><div id="inheritedMembers"></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
