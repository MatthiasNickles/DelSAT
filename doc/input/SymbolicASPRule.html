<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>delSAT 0.5.2 API  - input.SymbolicASPRule</title><meta content="delSAT 0.5.2 API - input.SymbolicASPRule" name="description"/><meta content="delSAT 0.5.2 API input.SymbolicASPRule" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.min.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title">delSAT 0.5.2 API<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.input" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="input"></a><a id="input:input"></a> <span class="permalink"><a href="../input/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="Find User API entry point classes input.ProbabilisticAnswerSetProgram (API for plain or probabilistic Answer Set Programming) and input.BooleanFormulaWithCosts (API for plain or probabilistic SAT solving) here"><span class="name">input</span></a></span><p class="shortcomment cmt">Find User API entry point classes <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> (API for plain or probabilistic Answer Set Programming) and <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a> (API for plain or probabilistic SAT solving) here
</p><div class="fullcomment"><div class="comment cmt"><p>Find User API entry point classes <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> (API for plain or probabilistic Answer Set Programming) and <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a> (API for plain or probabilistic SAT solving) here
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="AspifOrDIMACSPlainParserResult.html" title="Result of the aspif or dimacs parser." class="class"></a><a href="AspifOrDIMACSPlainParserResult.html" title="Result of the aspif or dimacs parser.">AspifOrDIMACSPlainParserResult</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="AspifPlainParser$.html" title="Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules." class="object"></a><a href="AspifPlainParser$.html" title="Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules.">AspifPlainParser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanClause.html" title="A disjunctive set of literals (hard clause)" class="class"></a><a href="BooleanClause.html" title="A disjunctive set of literals (hard clause)">BooleanClause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanFormulaWithCosts.html" title="A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)" class="class"></a><a href="BooleanFormulaWithCosts.html" title="A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)">BooleanFormulaWithCosts</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanLiteral.html" title="A literal, represented as a positive or negative integer value." class="class"></a><a href="BooleanLiteral.html" title="A literal, represented as a positive or negative integer value.">BooleanLiteral</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Clause.html" title="" class="class"></a><a href="Clause.html" title="">Clause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="DIMACPlainSparser$.html" title="Parser for DIMACS-CNF and PCNF (probabilistic CNF)." class="object"></a><a href="DIMACPlainSparser$.html" title="Parser for DIMACS-CNF and PCNF (probabilistic CNF).">DIMACPlainSparser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="GroundSymbolicASPRule.html" title="As input.SymbolicASPRule, but without variables." class="class"></a><a href="GroundSymbolicASPRule.html" title="As input.SymbolicASPRule, but without variables.">GroundSymbolicASPRule</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="InputData.html" title="Input data for the sampler/solver" class="class"></a><a href="InputData.html" title="Input data for the sampler/solver">InputData</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ParseOptimizationTerms$.html" title="" class="object"></a><a href="ParseOptimizationTerms$.html" title="">ParseOptimizationTerms</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ProbabilisticAnswerSetProgram.html" title="User API representation of a probabilistic or non-probabilistic ASP ground program, consisting of a set of input.GroundSymbolicASPRule rules (for the User API for probabilistic Boolean clauses, see input.BooleanFormulaWithCosts)." class="class"></a><a href="ProbabilisticAnswerSetProgram.html" title="User API representation of a probabilistic or non-probabilistic ASP ground program, consisting of a set of input.GroundSymbolicASPRule rules (for the User API for probabilistic Boolean clauses, see input.BooleanFormulaWithCosts).">ProbabilisticAnswerSetProgram</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ProbabilisticBooleanClause.html" title="A disjunctive set of literals, annotated with a probability (soft clause)." class="class"></a><a href="ProbabilisticBooleanClause.html" title="A disjunctive set of literals, annotated with a probability (soft clause).">ProbabilisticBooleanClause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="SolverParametersOverlay.html" title="Solver and sampling settings." class="class"></a><a href="SolverParametersOverlay.html" title="Solver and sampling settings.">SolverParametersOverlay</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="" title="Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~." class="class"></a><a href="" title="Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~.">SymbolicASPRule</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="diffSAT$.html" title="" class="object"></a><a href="diffSAT$.html" title="">diffSAT</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><div class="big-circle class">c</div><p id="owner"><a href="index.html" name="input" id="input" class="extype">input</a></p><h1>SymbolicASPRule<span class="permalink"><a href="../input/SymbolicASPRule.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><span class="name">SymbolicASPRule</span><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>, <span name="variableBindings">variableBindings: <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>)] = <span class="symbol">Seq()</span></span>, <span name="domainAtoms">domainAtoms: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Seq()</span></span>, <span name="distrPrOverGroundings">distrPrOverGroundings: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~.
Additionally, it supports probabilistic rules (rules with a probabilistic weight).
More complex ASP rule types can be created as combinations or desugarings using these basic types, see, e.g., Lifschitz, Turner: Nested Expressions in Logic Programs, 1999.
This data type fully supports ground rules but also has limited support for non-ground rules (for more advanced grounding
needs, it is recommended to use diff-SAT with an aspif file produced from the non-ground answer set program with a tool such as clingo).</p><p>This class also provides some support for non-ground rules, using parameters variableBindings and domainAtoms.
The rule can be grounded by calling <a href="#genGroundInstances:Seq[input.GroundSymbolicASPRule]" name="input.SymbolicASPRule#genGroundInstances" id="input.SymbolicASPRule#genGroundInstances" class="extmbr">input.SymbolicASPRule.genGroundInstances</a>.</p><p>However, for more complex grounding requirements, the answer set program should be translated into aspif format before calling diff-SAT,
using, e.g., clingo.</p><p>Complete examples can be found in <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> and <a href="../userAPItests/APITests.html" name="userAPItests.APITests" id="userAPItests.APITests" class="extype">userAPItests.APITests</a></p><h4>Default and classical negation</h4><p>To represent a classically ("strong") negated atom a, write -p(a). Allowed in head and body literals. "--p(a)" is not allowed.
To represent default negation in head or body literals, use prefix "not" (e.g., "not p(a)").
Double negation ("not not ") is also allowed, both in head and body literals. Triple negation ("not not not") is not supported.</p><p>Redundant whitespace in literals is not allowed. There must be exactly one space character after a "not" and there
mustn't be any whitespaces in literals except to separate "not".
E.g., "not f(X)" is ok, "  not  f ( X) " is invalid.</p><p>Supported rule types:</p><h4>Integrity constraints</h4><p>These are simply rules where the head is the empty set.</p><h4>"Weight rules" (ASP terminology. Unrelated to rules with probabilistic weights!)</h4><p>Instead of bodyLiterals there can be a weightBodySymbolicOpt in the form of Some(lowerBound, Seq((weight1, literal1), ..., (weightN, literalN)))
literal can here be "atom" or "not atom" (but not "not not atom"). Observe that more complex weight rules (e.g.,
with upper bound) can be desugared into multiple more basic rules.
If weightBodySymbolicOpt is defined, bodyLiterals must be empty (but rules with both weight aggregates and plain literals can
be created as combinations of more basic rules).</p><h4>Choice rules</h4><p>Instead of headLiterals, choiceHeadOpt can be present in form of Some(Seq(literal1, ..., literalN)), where
each literal can here be an "atom" (but not "not atom" or "not not atom"). Again, more complex rules (such as choice in bodies)
can be expressed as combinations of simpler rules.
Choice rules are often preferable in terms of complexity over disjunctions (i.e., more than one literal) in the head,
but observe that their semantics is different.
If choiceHeadOpt is defined, headLiterals must be empty.</p><h4>Probabilistic rules</h4><p>To express probabilistic facts, use special predicates _pr_ and _cost_ (must be facts, i.e., in head, with empty body).
E.g., "_pr_(heads(coin), 5000)" or  "_cost_(1 - f(coin))".</p><p>To attach a probability to an entire normal rule, you can use probabilityOpt. In this case, the rule must be normal, i.e,
have exactly one head literal which is positive and double negation or a weight body in the body aren't allowed.</p><p>A probability is represented as a double number w, 0&lt;=w&lt;=1.</p><p>Probabilistic rules don't have to be probabilistically independent from each other.</p><p>If the probabilityOpt=Some(-1), the probability is unknown (informally meaning 'rule v not rule', i.e., a
so-called _spanning rule_ [Nickles,Mileo 2015]).</p><h4>Basic grounding</h4><p>There is limited support for rule grounding (for a more powerful approach to grounding, use clingo/gringo or some
other modern ASP grounder to generate an aspif file which you can then use directly with diff-SAT):</p><p>Grounding is performed if variableBindings and/or variableDomains are provided.</p><p>variableBindings are processed linearly. E.g., rule r(X,Y) :- q(X), p(Y) with variableBindings Seq((X,"a"),(Y,"b"),(X,"c"))
results in a single ground rule r(a,b) :- q(a), p(b), because the second binding of X is ignored. To explore
all combinations, use something like concurrentBindings.flatMap(bindings -&gt; SymbolicASPRule(...,bindings,...))</p><p>In contrast to variableBindings, domainAtoms are processed by using all possible combinations.
E.g., r(X,Y) :- q(X), p(Y) with domainAtoms Seq("q(a)", "p(b)", "q(c)") results in two ground rules
r(a,b) :- q(a), p(b) and r(c,b) :- q(c), p(b)</p><p>variableBindings are processed before domainAtoms, so if any variable is already bound by variableBindings,
it cannot be re-bound by any domainAtoms.</p><p>domainAtoms (as a parameter of SymbolicASPRule) are not necessarily actually facts (in the logical sense) and they are
not automatically added as literals to the rule. If you want that, you need to add those "facts" explictly to
the bodyLiterals or make them actual facts as rules of their own.</p><p>Approaches (outside the scope of diff-SAT) to obtain domainAtoms could be, e.g., to deduce them as extension from given
ground rules where the involved predicates don't recursively depend on each other (as in lparse 1.0), or - less powerful -
to simply use all given ground facts (ground rules with empty body), or to use ground atoms in the body of the non-ground rule.</p><p>If a probability w is provided for a non-ground normal rule using probabilityOpt, it refers either to the conjunction of the
ground rules generated from the non-ground rule or to each individual ground rule, depending on distrPrOverGroundings.
E.g., with distrPrOverGroundings=false, Pr[p(X):-q(Y)] = w is equivalent to Pr[(p(a):-q(b)) <sup> (p(c):-q(a)) </sup> ...] = w,
if the ground instances of p(X):-q(Y) are p(a):-q(b), p(c):-q(a), ...
Whereas with distrPrOverGroundings=true, Pr[p(X):-q(Y)] = w is equivalent to Pr[p(a):-q(b)]=w <sup> Pr[p(c):-q(a)]=w </sup> ...</p><p>ASP variables are words consisting of characters and digits which start with an uppercase letter.
Variables can occur in any literals in the head and/or body.</p><p>Observe that gringo-style anonymous variables (_) or character ' in variables are not allowed here (but such variables
can be used when using clingo/gringo output with diff-SAT).</p><p>Variables in terms are recognized up to parantheses nesting level three.</p><p>diff-SAT doesn't distinguish between the case that a variable occurs in the head and the case it occurs in the body.
</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights!)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt;= p &lt;= 1 or -1 (see above)</p></dd><dt class="param">variableBindings</dt><dd class="cmt"><p>A list containing variable names (words starting with an uppercase letter) paired with ground terms.
                             For example, Seq(("X", "a1"), ("X", "a2"), ("Y", "b1"), ...).
                             Alternatively or additioally, domainAtoms can be provided to ground rules.</p></dd><dt class="param">domainAtoms</dt><dd class="cmt"><p>A list of ground atoms, e.g., "fac1(a,b)", "fac1(c,d)", "fac2(a)", ...).
                             Like variableBindings, they are used to ground rules (by determining further variable bindings).
                             NB: Ground facts listed here serve only to instantiate variables, they do not automatically become
                             body literals or even global facts. If you wish to add them, e.g., to the rule body, you need to append them
                             to bodyLiterals.
                             NB: redundant whitespace is not allowed in domain atoms and rule literals</p></dd><dt class="param">distrPrOverGroundings</dt><dd class="cmt"><p>If true (default), the probability probabilityOpt (if defined) is assumed to be the probability of each individual
                             ground instances of the rule (corresponding to weight syntax <span name="pr" class="extype">pr</span> in PrASP).
                             If false, the given probability (probabilityOpt, if defined) is the probability of the
                             entire conjunction of all ground instances of this rule (corresponding to weight syntax [pr] in PrASP).
                             Only relevant if there are variables in the literals, variableDomains is not empty, and probabilityOpt is defined.</p></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a>, <span name="scala.Product" class="extype">Product</span>, <span name="scala.Equals" class="extype">Equals</span>, <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="input.SymbolicASPRule"><span>SymbolicASPRule</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.Product"><span>Product</span></li><li class="in" name="scala.Equals"><span>Equals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="input.SymbolicASPRule#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="&lt;init&gt;(headLiterals:scala.collection.Set[aspIOutils.Pred],bodyLiterals:scala.collection.Set[aspIOutils.Pred],choiceHeadOpt:Option[Seq[aspIOutils.Pred]],weightBodySymbolicOpt:Option[(Int,Seq[(Int,aspIOutils.Pred)])],probabilityOpt:Option[Double],variableBindings:Seq[(String,String)],domainAtoms:Seq[String],distrPrOverGroundings:Boolean):input.SymbolicASPRule"></a><a id="&lt;init&gt;:SymbolicASPRule"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#&lt;init&gt;(headLiterals:scala.collection.Set[aspIOutils.Pred],bodyLiterals:scala.collection.Set[aspIOutils.Pred],choiceHeadOpt:Option[Seq[aspIOutils.Pred]],weightBodySymbolicOpt:Option[(Int,Seq[(Int,aspIOutils.Pred)])],probabilityOpt:Option[Double],variableBindings:Seq[(String,String)],domainAtoms:Seq[String],distrPrOverGroundings:Boolean):input.SymbolicASPRule" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">SymbolicASPRule</span><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>, <span name="variableBindings">variableBindings: <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>)] = <span class="symbol">Seq()</span></span>, <span name="domainAtoms">domainAtoms: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Seq()</span></span>, <span name="distrPrOverGroundings">distrPrOverGroundings: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span></span><p class="shortcomment cmt">Create an instance of this case class</p><div class="fullcomment"><div class="comment cmt"><p>Create an instance of this case class</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights!)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt;= p &lt;= 1 or -1 (see above)</p></dd><dt class="param">variableBindings</dt><dd class="cmt"><p>A list containing variable names (words starting with an uppercase letter) paired with ground terms.
                             For example, Seq(("X", "a1"), ("X", "a2"), ("Y", "b1"), ...).
                             Alternatively or additioally, domainAtoms can be provided to ground rules.</p></dd><dt class="param">domainAtoms</dt><dd class="cmt"><p>A list of ground atoms, e.g., "fac1(a,b)", "fac1(c,d)", "fac2(a)", ...).
                             Like variableBindings, they are used to ground rules (by determining further variable bindings).
                             NB: Ground facts listed here serve only to instantiate variables, they do not automatically become
                             body literals or even global facts. If you wish to add them, e.g., to the rule body, you need to append them
                             to bodyLiterals.
                             NB: redundant whitespace is not allowed in domain atoms and rule literals</p></dd><dt class="param">distrPrOverGroundings</dt><dd class="cmt"><p>If true (default), the probability probabilityOpt (if defined) is assumed to be the probability of each individual
                             ground instances of the rule (corresponding to weight syntax <span name="pr" class="extype">pr</span> in PrASP).
                             If false, the given probability (probabilityOpt, if defined) is the probability of the
                             entire conjunction of all ground instances of this rule (corresponding to weight syntax [pr] in PrASP).
                             Only relevant if there are variables in the literals, variableDomains is not empty, and probabilityOpt is defined.</p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#anyVariableNameRegex" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="anyVariableNameRegex:scala.util.matching.Regex"></a><a id="anyVariableNameRegex:Regex"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#anyVariableNameRegex:scala.util.matching.Regex" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">anyVariableNameRegex</span><span class="result">: <span name="scala.util.matching.Regex" class="extype">Regex</span></span></span></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#bodyLiterals" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="bodyLiterals:scala.collection.Set[aspIOutils.Pred]"></a><a id="bodyLiterals:Set[Pred]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#bodyLiterals:scala.collection.Set[aspIOutils.Pred]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">bodyLiterals</span><span class="result">: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]</span></span></li><li class="indented0 " name="input.SymbolicASPRule#choiceHeadOpt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="choiceHeadOpt:Option[Seq[aspIOutils.Pred]]"></a><a id="choiceHeadOpt:Option[Seq[Pred]]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#choiceHeadOpt:Option[Seq[aspIOutils.Pred]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">choiceHeadOpt</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]]</span></span></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#distrPrOverGroundings" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="distrPrOverGroundings:Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#distrPrOverGroundings:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">distrPrOverGroundings</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span></li><li class="indented0 " name="input.SymbolicASPRule#domainAtoms" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="domainAtoms:Seq[String]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#domainAtoms:Seq[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">domainAtoms</span><span class="result">: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>]</span></span></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#genGroundInstances" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="genGroundInstances:Seq[input.GroundSymbolicASPRule]"></a><a id="genGroundInstances:Seq[GroundSymbolicASPRule]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#genGroundInstances:Seq[input.GroundSymbolicASPRule]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">genGroundInstances</span><span class="result">: <span name="scala.Seq" class="extype">Seq</span>[<a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">GroundSymbolicASPRule</a>]</span></span><p class="shortcomment cmt">Grounds this rule using the domains specified by variableBindings and domainAtoms.</p><div class="fullcomment"><div class="comment cmt"><p>Grounds this rule using the domains specified by variableBindings and domainAtoms.</p><p>ASP variables are words consisting of characters and digits which start with an uppercase letter.
Variables can occur in any literals in the head and/or body.
Observe that gringo-style anonymous variables (_) or character ' in variables are not allowed here (but such variables
can be used when using clingo/gringo output with diff-SAT).
Variables in terms are recognized up to parantheses nesting level three.
Literals must not contain any redundant space. E.g., "not f(X)" is ok, "  not  f(X) " is invalid.
Also observe that diff-SAT doesn't care if a variable is in the head or in the body, and that it
does not automatically add domain facts to the knowledge base.</p><p>A probabilistic rule weight is resolved using the semantics specified by flag distrPrOverGroundings in the rule constructor.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a list of symbolic ground rules (the instances of the non-ground rule, plus helper rules in
        case of a probabilistic rule). Result is empty if unification failed (grounding impossible).</p></dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#genGroundInstancesRec" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="genGroundInstancesRec:Seq[input.SymbolicASPRule]"></a><a id="genGroundInstancesRec:Seq[SymbolicASPRule]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#genGroundInstancesRec:Seq[input.SymbolicASPRule]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">genGroundInstancesRec</span><span class="result">: <span name="scala.Seq" class="extype">Seq</span>[<a href="" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">SymbolicASPRule</a>]</span></span><p class="shortcomment cmt">Don't call directly, call via genGroundInstances()
</p><div class="fullcomment"><div class="comment cmt"><p>Don't call directly, call via genGroundInstances()
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>Set of SymbolicASPRule (empty if unification failed)</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#headLiterals" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="headLiterals:scala.collection.Set[aspIOutils.Pred]"></a><a id="headLiterals:Set[Pred]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#headLiterals:scala.collection.Set[aspIOutils.Pred]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">headLiterals</span><span class="result">: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]</span></span></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#probabilityOpt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="probabilityOpt:Option[Double]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#probabilityOpt:Option[Double]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">probabilityOpt</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>]</span></span></li><li class="indented0 " name="scala.Product#productElementNames" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="productElementNames:Iterator[String]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#productElementNames:Iterator[String]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">productElementNames</span><span class="result">: <span name="scala.Iterator" class="extype">Iterator</span>[<span name="scala.Predef.String" class="extype">String</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Product</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <span name="scala.Predef.String" class="extype">String</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">SymbolicASPRule</a> → AnyRef → Any</dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#variableBindings" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="variableBindings:Seq[(String,String)]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#variableBindings:Seq[(String,String)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">variableBindings</span><span class="result">: <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>)]</span></span></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule#weightBodySymbolicOpt" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="weightBodySymbolicOpt:Option[(Int,Seq[(Int,aspIOutils.Pred)])]"></a><a id="weightBodySymbolicOpt:Option[(Int,Seq[(Int,Pred)])]"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html#weightBodySymbolicOpt:Option[(Int,Seq[(Int,aspIOutils.Pred)])]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">val</span></span> <span class="symbol"><span class="name">weightBodySymbolicOpt</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>)])]</span></span></li></ol></div></div><div id="inheritedMembers"><div name="java.io.Serializable" class="parent"><h3>Inherited from <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html#java.io.Serializable" name="java.io.Serializable" id="java.io.Serializable" class="extype">Serializable</a></h3></div><div name="scala.Product" class="parent"><h3>Inherited from <span name="scala.Product" class="extype">Product</span></h3></div><div name="scala.Equals" class="parent"><h3>Inherited from <span name="scala.Equals" class="extype">Equals</span></h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
