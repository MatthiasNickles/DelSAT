<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>delSAT 0.5.2 API  - input</title><meta content="delSAT 0.5.2 API - input" name="description"/><meta content="delSAT 0.5.2 API input" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../lib/jquery.min.js"></script><script type="text/javascript" src="../lib/index.js"></script><script type="text/javascript" src="../index.js"></script><script type="text/javascript" src="../lib/scheduler.js"></script><script type="text/javascript" src="../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../';</script></head><body><div id="search"><span id="doc-title">delSAT 0.5.2 API<span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 current" name="_root_.input" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="input"></a><a id="input:input"></a> <span class="permalink"><a href="../input/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">input</span></span><p class="shortcomment cmt">Find User API entry point classes <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> (API for plain or probabilistic Answer Set Programming) and <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a> (API for plain or probabilistic SAT solving) here
</p><div class="fullcomment"><div class="comment cmt"><p>Find User API entry point classes <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> (API for plain or probabilistic Answer Set Programming) and <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a> (API for plain or probabilistic SAT solving) here
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="current-entities indented1"><span class="separator"></span> <a href="AspifOrDIMACSPlainParserResult.html" title="Result of the aspif or dimacs parser." class="class"></a><a href="AspifOrDIMACSPlainParserResult.html" title="Result of the aspif or dimacs parser.">AspifOrDIMACSPlainParserResult</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="AspifPlainParser$.html" title="Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules." class="object"></a><a href="AspifPlainParser$.html" title="Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules.">AspifPlainParser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanClause.html" title="A disjunctive set of literals (hard clause)" class="class"></a><a href="BooleanClause.html" title="A disjunctive set of literals (hard clause)">BooleanClause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanFormulaWithCosts.html" title="A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)" class="class"></a><a href="BooleanFormulaWithCosts.html" title="A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)">BooleanFormulaWithCosts</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="BooleanLiteral.html" title="A literal, represented as a positive or negative integer value." class="class"></a><a href="BooleanLiteral.html" title="A literal, represented as a positive or negative integer value.">BooleanLiteral</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="Clause.html" title="" class="class"></a><a href="Clause.html" title="">Clause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="DIMACPlainSparser$.html" title="Parser for DIMACS-CNF and PCNF (probabilistic CNF)." class="object"></a><a href="DIMACPlainSparser$.html" title="Parser for DIMACS-CNF and PCNF (probabilistic CNF).">DIMACPlainSparser</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="GroundSymbolicASPRule.html" title="As input.SymbolicASPRule, but without variables." class="class"></a><a href="GroundSymbolicASPRule.html" title="As input.SymbolicASPRule, but without variables.">GroundSymbolicASPRule</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="InputData.html" title="Input data for the sampler/solver" class="class"></a><a href="InputData.html" title="Input data for the sampler/solver">InputData</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ParseOptimizationTerms$.html" title="" class="object"></a><a href="ParseOptimizationTerms$.html" title="">ParseOptimizationTerms</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ProbabilisticAnswerSetProgram.html" title="User API representation of a probabilistic or non-probabilistic ASP ground program, consisting of a set of input.GroundSymbolicASPRule rules (for the User API for probabilistic Boolean clauses, see input.BooleanFormulaWithCosts)." class="class"></a><a href="ProbabilisticAnswerSetProgram.html" title="User API representation of a probabilistic or non-probabilistic ASP ground program, consisting of a set of input.GroundSymbolicASPRule rules (for the User API for probabilistic Boolean clauses, see input.BooleanFormulaWithCosts).">ProbabilisticAnswerSetProgram</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="ProbabilisticBooleanClause.html" title="A disjunctive set of literals, annotated with a probability (soft clause)." class="class"></a><a href="ProbabilisticBooleanClause.html" title="A disjunctive set of literals, annotated with a probability (soft clause).">ProbabilisticBooleanClause</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="SolverParametersOverlay.html" title="Solver and sampling settings." class="class"></a><a href="SolverParametersOverlay.html" title="Solver and sampling settings.">SolverParametersOverlay</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="SymbolicASPRule.html" title="Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~." class="class"></a><a href="SymbolicASPRule.html" title="Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~.">SymbolicASPRule</a></li><li class="current-entities indented1"><span class="separator"></span> <a href="diffSAT$.html" title="" class="object"></a><a href="diffSAT$.html" title="">diffSAT</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><h1>input<span class="permalink"><a href="../input/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">input</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Find User API entry point classes <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> (API for plain or probabilistic Answer Set Programming) and <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a> (API for plain or probabilistic SAT solving) here
</p></div><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="input"><span>input</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="input.AspifOrDIMACSPlainParserResult" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="AspifOrDIMACSPlainParserResultextendsProductwithSerializable"></a><a id="AspifOrDIMACSPlainParserResult:AspifOrDIMACSPlainParserResult"></a> <span class="permalink"><a href="../input/AspifOrDIMACSPlainParserResult.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="AspifOrDIMACSPlainParserResult.html" title="Result of the aspif or dimacs parser."><span class="name">AspifOrDIMACSPlainParserResult</span></a><span class="params">(<span name="symbols">symbols: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Predef.String" class="extype">String</span>]</span>, <span name="rulesOrClauseNogoods">rulesOrClauseNogoods: <span name="scala.Either" class="extype">Either</span>[<span name="scala.collection.mutable.ArrayBuffer" class="extype">ArrayBuffer</span>[<a href="../sharedDefs/package$$Rule.html" name="sharedDefs.Rule" id="sharedDefs.Rule" class="extype">Rule</a>], <span name="scala.Array" class="extype">Array</span>[<a href="../utils/IntArrayUnsafeS.html" name="utils.IntArrayUnsafeS" id="utils.IntArrayUnsafeS" class="extype">IntArrayUnsafeS</a>]]</span>, <span name="noOfPosBlits">noOfPosBlits: <span name="scala.Int" class="extype">Int</span></span>, <span name="noOfDummySymbols">noOfDummySymbols: <span name="scala.Int" class="extype">Int</span></span>, <span name="externalAtomElis">externalAtomElis: <span name="scala.Seq" class="extype">Seq</span>[<a href="../sharedDefs/index.html#Eli=Int" name="sharedDefs.Eli" id="sharedDefs.Eli" class="extmbr">Eli</a>]</span>, <span name="assumptionElis">assumptionElis: <span name="scala.Seq" class="extype">Seq</span>[<a href="../sharedDefs/index.html#Eli=Int" name="sharedDefs.Eli" id="sharedDefs.Eli" class="extmbr">Eli</a>]</span>, <span name="emptyBodyBlit">emptyBodyBlit: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">-1</span></span>, <span name="clausesForChecksOpt">clausesForChecksOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Array" class="extype">Array</span>[<span name="scala.Array" class="extype">Array</span>[<span name="scala.Int" class="extype">Int</span>]]]</span>, <span name="symbolToEliOpt">symbolToEliOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Predef.Map" class="extype">Map</span>[<span name="scala.Predef.String" class="extype">String</span>, <a href="../sharedDefs/index.html#Eli=Int" name="sharedDefs.Eli" id="sharedDefs.Eli" class="extmbr">Eli</a>]]</span>, <span name="additionalUncertainAtomsInnerCostsStrs">additionalUncertainAtomsInnerCostsStrs: (<span name="scala.Array" class="extype">Array</span>[<span name="scala.Predef.String" class="extype">String</span>], <span name="scala.Array" class="extype">Array</span>[<span name="scala.Predef.String" class="extype">String</span>], <span name="scala.Array" class="extype">Array</span>[<span name="scala.Predef.String" class="extype">String</span>])</span>, <span name="aspifEliToSymbolOpt">aspifEliToSymbolOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.collection.mutable.HashMap" class="extype">HashMap</span>[<a href="AspifPlainParser$.html#AspifEli=Int" name="input.AspifPlainParser.AspifEli" id="input.AspifPlainParser.AspifEli" class="extmbr">AspifEli</a>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]] = <span class="symbol">None</span></span>, <span name="aspifRulesOpt">aspifRulesOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.collection.mutable.ArrayBuffer" class="extype">ArrayBuffer</span>[<a href="AspifPlainParser$$AspifRule.html" name="input.AspifPlainParser.AspifRule" id="input.AspifPlainParser.AspifRule" class="extype">AspifRule</a>]] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Result of the aspif or dimacs parser.</p><div class="fullcomment"><div class="comment cmt"><p>Result of the aspif or dimacs parser. Also see <a href="InputData.html" name="input.InputData" id="input.InputData" class="extype">input.InputData</a></p></div></div></li><li class="indented0 " name="input.BooleanClause" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BooleanClauseextendsClausewithProductwithSerializable"></a><a id="BooleanClause:BooleanClause"></a> <span class="permalink"><a href="../input/BooleanClause.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="BooleanClause.html" title="A disjunctive set of literals (hard clause)"><span class="name">BooleanClause</span></a><span class="params">(<span name="literals">literals: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="BooleanLiteral.html" name="input.BooleanLiteral" id="input.BooleanLiteral" class="extype">BooleanLiteral</a>]</span>)</span><span class="result"> extends <a href="Clause.html" name="input.Clause" id="input.Clause" class="extype">Clause</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A disjunctive set of literals (hard clause)
</p></li><li class="indented0 " name="input.BooleanFormulaWithCosts" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="BooleanFormulaWithCostsextendsProductwithSerializable"></a><a id="BooleanFormulaWithCosts:BooleanFormulaWithCosts"></a> <span class="permalink"><a href="../input/BooleanFormulaWithCosts.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="BooleanFormulaWithCosts.html" title="A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)"><span class="name">BooleanFormulaWithCosts</span></a><span class="params">(<span name="clauses">clauses: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="Clause.html" name="input.Clause" id="input.Clause" class="extype">Clause</a>]</span>, <span name="maxVar">maxVar: <span name="scala.Int" class="extype">Int</span> = <span class="symbol">-1</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)</p><div class="fullcomment"><div class="comment cmt"><p>A collection of probabilistic and/or non-probabilistic Boolean clauses (disjunctions of literals)</p><p>User API part for probabilistic SAT solving and multimodel optimization (for the User API part for probabilistic Answer Set
Programming see <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a>)</p><p>Example:
Construct CNF and specify multimodel optimization goal:</p><pre><span class="cmt">// The following API calls corresponds to solving the following Enhanced DIMACS CNF file:</span>
<span class="cmt">//</span>
<span class="cmt">//  1 -1 0</span>
<span class="cmt">//  2 -2 0</span>
<span class="cmt">//  -1 -2 0</span>
<span class="cmt">//</span>
<span class="cmt">//  pats 1 2</span>
<span class="cmt">//</span>
<span class="cmt">//  cost (0.2-f(v1))^2</span>
<span class="cmt">//  cost (0.5-f(v2))^2</span>
<span class="cmt">//</span>

<span class="kw">val</span> clause1 = BooleanClause(literals = <span class="std">Set</span>(BooleanLiteral(<span class="num">1</span>), BooleanLiteral(-<span class="num">1</span>)))

<span class="kw">val</span> clause2 = BooleanClause(literals = <span class="std">Set</span>(BooleanLiteral(<span class="num">2</span>), BooleanLiteral(-<span class="num">2</span>)))

<span class="kw">val</span> clause3 = BooleanClause(literals = <span class="std">Set</span>(BooleanLiteral(-<span class="num">1</span>), BooleanLiteral(-<span class="num">2</span>)))

<span class="kw">val</span> booleanFormula: BooleanFormulaWithCosts = BooleanFormulaWithCosts(<span class="std">Set</span>(clause1, clause2, clause3))

<span class="kw">val</span> probabilisticObjectives =  <span class="cmt">// Parameter atoms are "1" and "2". Atom "1" has probability 0.2, "2" has probability 0.5</span>
  <span class="lit">"""pats 1 2

     cost (0.2-f(v1))^2
     cost (0.5-f(v2))^2
  """
  // (Alternatively, cost (loss) terms can be constructed programmatically (see ParseOptimizationTerms to get an idea how to do
  // this. Also consider using the ASP User API ([[input.ProbabilisticAnswerSetProgram]]) which allows to work
  // with symbolic atoms and rules.)</span></pre><p>     Invoke sampler and examine the resulting sample (a set of models):</p><pre><span class="kw">val</span> solverParams = input.SolverParametersOverlay(
  noOfModels = -<span class="num">1</span>, <span class="cmt">// -1 means sample until desired accuracy (thresholdOpt) has been reached. A positive</span>
   <span class="cmt">// number would specify a minimum sample size (number of answer sets).</span>
  noOfSecondaryModels = <span class="num">0</span>,
  offHeapGarbageCollectionModeR = <span class="num">0</span>,
  thresholdOpt = <span class="std">Some</span>(<span class="num">0.001</span>d), <span class="cmt">// the desired accuracy (lower = more accurate but sampling requires more time)</span>
  assureMSE = <span class="kw">true</span>, <span class="cmt">// true = the loss function is assured to be of type MSE (false works too but true is more efficient)</span>
  showauxInSATmode = <span class="kw">false</span>,
  advancedSolverArgs = mutable.HashMap[(<span class="std">String</span>, <span class="std">Int</span>), <span class="std">String</span>](  <span class="cmt">// advanced solver parameters (corresponding to --solverarg commandline parameters)</span>
      (<span class="lit">"seedRngGlobalR"</span>, <span class="num">0</span>) -&gt; <span class="lit">"-1"</span> <span class="cmt">// uses a random PRNG seed seed for each run. Otherwise, we would get the same set of models at each call.</span>
    , (<span class="lit">"diversify"</span>, <span class="num">0</span>) -&gt; <span class="lit">"false"</span> <span class="cmt">// "true" increases the entropy - with false, we might get a highly non-uniform distribution if there are no probabilities specified</span>
  )
)

<span class="kw">val</span> sampled: SamplingResult = booleanFormula.solve(solverParams,
  paramAtomsAndInnerCostsStrOpt = <span class="std">Some</span>(probabilisticObjectives))

<span class="cmt">// Print sample and the result of ad hoc query Pr[p(a):-not q AND p(b):-not q]:</span>

<span class="kw">val</span> (_, adHocConjunctiveQueriesResults, adHocDisjunctiveQueriesResults, adHocRuleQueriesResults,
adHocConjunctionOfSimpleGroundRulesQuery) = delSAT.queryAndPrintSolverResult(showauxInASPmode = <span class="kw">false</span>,
  satMode = <span class="kw">true</span>,
  samplingResult = sampled,
  adHocConjunctiveQueries = <span class="std">Seq</span>(<span class="std">Seq</span>(<span class="lit">"1"</span>), <span class="std">Seq</span>(<span class="lit">"2"</span>)),
  adHocDisjunctiveQueries = <span class="std">Seq</span>(),
  adHocConjunctionOfSimpleGroundRulesQuery = <span class="std">Seq</span>(),
  printAdHocQueryResults = <span class="kw">true</span>,
  printAnswers = <span class="kw">true</span>)

println(adHocConjunctiveQueriesResults)</pre><p>Further examples can be found in the source code of <a href="../userAPItests/APITests.html" name="userAPItests.APITests" id="userAPItests.APITests" class="extype">userAPItests.APITests</a>
</p></div><dl class="paramcmts block"><dt class="param">maxVar</dt><dd class="cmt"><p>: largest (by name) propositional variable. If -1 it will be automatically determined.</p></dd></dl></div></li><li class="indented0 " name="input.BooleanLiteral" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="BooleanLiteralextendsAnyValwithProductwithSerializable"></a><a id="BooleanLiteral:BooleanLiteral"></a> <span class="permalink"><a href="../input/BooleanLiteral.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="BooleanLiteral.html" title="A literal, represented as a positive or negative integer value."><span class="name">BooleanLiteral</span></a><span class="params">(<span name="value">value: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result"> extends <span name="scala.AnyVal" class="extype">AnyVal</span> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A literal, represented as a positive or negative integer value.</p><div class="fullcomment"><div class="comment cmt"><p>A literal, represented as a positive or negative integer value. The sign represents its logical polarity.
Value 0 is not allowed.
</p></div></div></li><li class="indented0 " name="input.Clause" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ClauseextendsAnyRef"></a><a id="Clause:Clause"></a> <span class="permalink"><a href="../input/Clause.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Clause.html" title=""><span class="name">Clause</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></li><li class="indented0 " name="input.GroundSymbolicASPRule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="GroundSymbolicASPRuleextendsProductwithSerializable"></a><a id="GroundSymbolicASPRule:GroundSymbolicASPRule"></a> <span class="permalink"><a href="../input/GroundSymbolicASPRule.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="GroundSymbolicASPRule.html" title="As input.SymbolicASPRule, but without variables."><span class="name">GroundSymbolicASPRule</span></a><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">As <a href="SymbolicASPRule.html" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">input.SymbolicASPRule</a>, but without variables.</p><div class="fullcomment"><div class="comment cmt"><p>As <a href="SymbolicASPRule.html" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">input.SymbolicASPRule</a>, but without variables. See <a href="SymbolicASPRule.html" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">input.SymbolicASPRule</a> for supported rule types.
</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights used elsewhere)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt; p &lt; 1 or -1 (see above)</p></dd></dl></div></li><li class="indented0 " name="input.InputData" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="InputDataextendsProductwithSerializable"></a><a id="InputData:InputData"></a> <span class="permalink"><a href="../input/InputData.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">case class</span></span> <span class="symbol"><a href="InputData.html" title="Input data for the sampler/solver"><span class="name">InputData</span></a><span class="params">(<span name="aspifOrDIMACSPlainParserResult">aspifOrDIMACSPlainParserResult: <a href="AspifOrDIMACSPlainParserResult.html" name="input.AspifOrDIMACSPlainParserResult" id="input.AspifOrDIMACSPlainParserResult" class="extype">AspifOrDIMACSPlainParserResult</a></span>, <span name="costsOpt">costsOpt: <span name="scala.Option" class="extype">Option</span>[<span name="diff.UncertainAtomsSeprt" class="extype">UncertainAtomsSeprt</span>]</span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Input data for the sampler/solver</p></li><li class="indented0 " name="input.ProbabilisticAnswerSetProgram" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ProbabilisticAnswerSetProgramextendsProductwithSerializable"></a><a id="ProbabilisticAnswerSetProgram:ProbabilisticAnswerSetProgram"></a> <span class="permalink"><a href="../input/ProbabilisticAnswerSetProgram.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ProbabilisticAnswerSetProgram.html" title="User API representation of a probabilistic or non-probabilistic ASP ground program, consisting of a set of input.GroundSymbolicASPRule rules (for the User API for probabilistic Boolean clauses, see input.BooleanFormulaWithCosts)."><span class="name">ProbabilisticAnswerSetProgram</span></a><span class="params">(<span name="groundSymbolicASPRules">groundSymbolicASPRules: <span name="scala.collection.Set" class="extype">Set</span>[<a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">GroundSymbolicASPRule</a>]</span>, <span name="backgroundProgramAspifOpt">backgroundProgramAspifOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">None</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">User API representation of a probabilistic or non-probabilistic ASP ground program,
consisting of a set of <a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">input.GroundSymbolicASPRule</a> rules (for the User API for probabilistic Boolean clauses, see <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a>).</p><div class="fullcomment"><div class="comment cmt"><p>User API representation of a probabilistic or non-probabilistic ASP ground program,
consisting of a set of <a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">input.GroundSymbolicASPRule</a> rules (for the User API for probabilistic Boolean clauses, see <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a>).</p><p>Some forms of non-ground rules are supported too (see <a href="SymbolicASPRule.html" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">input.SymbolicASPRule</a>) but these must be grounded into
sets of ground rules by calling <a href="SymbolicASPRule.html#genGroundInstances:Seq[input.GroundSymbolicASPRule]" name="input.SymbolicASPRule#genGroundInstances" id="input.SymbolicASPRule#genGroundInstances" class="extmbr">input.SymbolicASPRule.genGroundInstances</a> before solving/sampling.</p><p>Optionally, a background program in aspif format can be specified using parameter backgroundProgramAspifOpt.
In this case, the rules specified using GroundSymbolicASPRule are added to those in the background program.</p><p>To specify arbitrary differentiable loss functions (beyond those indirectly specified using probabilistic rule weights) and parameter
atoms, use parameter paramAtomsAndInnerCostsStrOpt in method solve(). An example for this is analogous to the example
in <a href="BooleanFormulaWithCosts.html" name="input.BooleanFormulaWithCosts" id="input.BooleanFormulaWithCosts" class="extype">input.BooleanFormulaWithCosts</a>.</p><p>For how to use complex non-ground answer set programs (in aspif format), please refer to README.md</p><p>Solver settings are provided using <a href="SolverParametersOverlay.html" name="input.SolverParametersOverlay" id="input.SolverParametersOverlay" class="extype">input.SolverParametersOverlay</a>.
The names and default values of available advanced settings (advancedSolverArgs) within this structure are listed in <a href="../sharedDefs/index.html" name="sharedDefs" id="sharedDefs" class="extype">sharedDefs</a></p><h4>API usage example 1: Sampling with probabilistic ground rules</h4><pre><span class="kw">val</span> rules: <span class="std">Set</span>[GroundSymbolicASPRule] = <span class="std">Set</span>(

  <span class="cmt">/*
      [0.7] p :- not q.  % rule has probability 0.7
      {q}. % we need this choice rule just to ensure predicate q is defined
      {p}.
  */</span>

  GroundSymbolicASPRule(headLiterals = <span class="std">Set</span>(<span class="lit">"p"</span>), bodyLiterals = <span class="std">Set</span>(<span class="lit">"not q"</span>),
   probabilityOpt = <span class="std">Some</span>(<span class="num">0.7</span>d) <span class="cmt">// Probability of the ground rule (use 'None' for a hard rule)</span>
   )
  , GroundSymbolicASPRule(choiceHeadOpt = <span class="std">Some</span>(<span class="std">Seq</span>(<span class="lit">"p"</span>)))
  , GroundSymbolicASPRule(choiceHeadOpt = <span class="std">Some</span>(<span class="std">Seq</span>(<span class="lit">"q"</span>)))

)

<span class="kw">val</span> solverParams = SolverParametersOverlay(
  noOfModels = -<span class="num">1</span>, <span class="cmt">// -1 means sample until desired accuracy (loss threshold) has been reached. A positive</span>
  <span class="cmt">// number would specify a minimum sample size (in terms of number of answer sets).</span>
  noOfSecondaryModels = <span class="num">0</span>,
  offHeapGarbageCollectionModeR = <span class="num">0</span>,
  thresholdOpt = <span class="std">Some</span>(<span class="num">1</span>e-<span class="num">5</span>d), <span class="cmt">// the desired accuracy (lower = more accurate but sampling requires more time)</span>
  assureMSE = <span class="kw">true</span>, <span class="cmt">// true = the loss function (which in this example is automatically generated from the probabilistic facts)</span>
   <span class="cmt">// is assured to be of type MSE</span>
  showauxInSATmode = <span class="kw">false</span>,
  advancedSolverArgs = mutable.HashMap[(<span class="std">String</span>, <span class="std">Int</span>), <span class="std">String</span>]( <span class="cmt">// advanced settings, see sharedDefs</span>
    (<span class="lit">"seedRngGlobalR"</span>, <span class="num">0</span>) -&gt; <span class="lit">"-1"</span> <span class="cmt">// uses a random PRNG seed seed for each run. Otherwise, we would get the same set of models at each call.</span>
    , (<span class="lit">"diversify"</span>, <span class="num">0</span>) -&gt; <span class="lit">"false"</span> <span class="cmt">// "true" increases the entropy - with false, we might get a highly non-uniform distribution if there are no probabilities specified</span>
  )
)

<span class="cmt">// Create the program from the rules and parameters and sample models:</span>
<span class="kw">val</span> sampled: SamplingResult = ProbabilisticAnswerSetProgram(rules, backgroundProgramAspifOpt = <span class="std">None</span>).
  solve(solverParams, paramAtomsAndInnerCostsStrOpt = <span class="std">None</span>)

<span class="cmt">// Print sample and the result of ad hoc query Pr(q AND p):</span>
<span class="kw">val</span> (_, adHocConjunctiveQueriesResults, adHocDisjunctiveQueriesResults, adHocRuleQueriesResults, adHocConjunctionOfSimpleGroundRulesQuery) = diffSAT.queryAndPrintSolverResult(showauxInASPmode = <span class="kw">false</span>,
  satMode = <span class="kw">false</span>,
  samplingResult = sampled,
  adHocConjunctiveQueries = <span class="std">Seq</span>(),
  adHocDisjunctiveQueries = <span class="std">Seq</span>(<span class="std">Seq</span>(<span class="lit">"q"</span>, <span class="lit">"p"</span>)),
  printAdHocQueryResults = <span class="kw">true</span>,
  printAnswers = <span class="kw">true</span>)</pre><h4>API usage example 2: Sampling with probabilistic non-ground rules</h4><pre><span class="kw">val</span> domainAtoms = <span class="std">Seq</span>(<span class="lit">"p(a)"</span>, <span class="lit">"p(b)"</span>) <span class="cmt">// For grounding. Observe that these atoms don't automatically become facts or body literals.</span>

<span class="kw">val</span> uncertainNongroundRuleGroundings: <span class="std">Seq</span>[GroundSymbolicASPRule] = SymbolicASPRule(
  headLiterals = <span class="std">Set</span>(<span class="lit">"p(X)"</span>),
  bodyLiterals = <span class="std">Set</span>(<span class="lit">"not q"</span>),
  domainAtoms = domainAtoms,
  probabilityOpt = <span class="std">Some</span>(<span class="num">0.7</span>d),  <span class="cmt">// Probability of the rule (use 'None' for a hard rule)</span>
  distrPrOverGroundings = <span class="kw">false</span> <span class="cmt">// with false, the probability applies to the entire non-ground rule.</span>
   <span class="cmt">// With true (which might be more useful in practice), it would apply to each ground instance rule individually.</span>
  ).genGroundInstances

println(<span class="lit">"\n------------- Ground instances of [0.7] p(X) :- not q :\n"</span> + uncertainNongroundRuleGroundings.mkString(<span class="lit">"\n"</span>))

<span class="kw">val</span> groundRules: <span class="std">Set</span>[GroundSymbolicASPRule] = { <span class="cmt">// all ground rules of the program</span>
  <span class="cmt">/*
        #domain p(a).
        #domain p(b).

        [0.7] p(X) :- not q.
        {p(a)}.
        {p(b)}.
        {q}.
    */</span>

  uncertainNongroundRuleGroundings ++
    SymbolicASPRule(choiceHeadOpt = <span class="std">Some</span>(<span class="std">Seq</span>(<span class="lit">"p(a)"</span>))).genGroundInstances ++
    SymbolicASPRule(choiceHeadOpt = <span class="std">Some</span>(<span class="std">Seq</span>(<span class="lit">"p(b)"</span>))).genGroundInstances ++
    <span class="std">Seq</span>(GroundSymbolicASPRule(choiceHeadOpt = <span class="std">Some</span>(<span class="std">Seq</span>(<span class="lit">"not q"</span>))))


}.toSet

<span class="cmt">//println("\n------------- Grounding:\n" + groundRules.mkString("\n"))</span>

<span class="kw">val</span> solverParams = SolverParametersOverlay(
  noOfModels = -<span class="num">1</span>, <span class="cmt">// -1 means sample until desired accuracy (thresholdOpt) has been reached. A positive</span>
  <span class="cmt">// number would specify a minimum sample size (number of answer sets).</span>
  noOfSecondaryModels = <span class="num">0</span>,
  offHeapGarbageCollectionModeR = <span class="num">0</span>,
  thresholdOpt = <span class="std">Some</span>(<span class="num">1</span>e-<span class="num">20</span>d), <span class="cmt">// the desired accuracy (lower = more accurate but sampling requires more time)</span>
  assureMSE = <span class="kw">true</span>, <span class="cmt">// true = the loss function (which in this example is automatically generated from the probabilistic facts)</span>
  <span class="cmt">// is assured to be of type MSE</span>
  showauxInSATmode = <span class="kw">false</span>,
  advancedSolverArgs = mutable.HashMap[(<span class="std">String</span>, <span class="std">Int</span>), <span class="std">String</span>]( <span class="cmt">// advanced settings, see sharedDefs</span>
    (<span class="lit">"seedRngGlobalR"</span>, <span class="num">0</span>) -&gt; <span class="lit">"-1"</span> <span class="cmt">// uses a random PRNG seed seed for each run. Otherwise, we would get the same set of models at each call.</span>
    , (<span class="lit">"diversify"</span>, <span class="num">0</span>) -&gt; <span class="lit">"false"</span> <span class="cmt">// "true" increases the entropy - with false, we might get a highly non-uniform distribution if there are no probabilities specified</span>
  )
)

<span class="cmt">// Create the program from the rules and parameters and sample models:</span>

<span class="kw">val</span> sampled: SamplingResult = ProbabilisticAnswerSetProgram(groundRules, backgroundProgramAspifOpt = <span class="std">None</span>).
  solve(solverParams, paramAtomsAndInnerCostsStrOpt = <span class="std">None</span>)

<span class="cmt">// Print sample and the result of ad hoc query Pr[p(a):-not q AND p(b):-not q]:</span>

<span class="kw">val</span> (_, adHocConjunctiveQueriesResults, adHocDisjunctiveQueriesResults, adHocRuleQueriesResults,
adHocConjunctionOfSimpleGroundRulesQuery) = diffSAT.queryAndPrintSolverResult(showauxInASPmode = <span class="kw">false</span>,
  satMode = <span class="kw">false</span>,
  samplingResult = sampled,
  adHocConjunctiveQueries = <span class="std">Seq</span>(),
  adHocDisjunctiveQueries = <span class="std">Seq</span>(),
  adHocConjunctionOfSimpleGroundRulesQuery = <span class="std">Seq</span>((<span class="lit">"p(a)"</span>, <span class="std">Seq</span>(<span class="lit">"not q"</span>)), (<span class="lit">"p(b)"</span>, <span class="std">Seq</span>(<span class="lit">"not q"</span>))), <span class="cmt">// we use</span>
  <span class="cmt">// adHocConjunctionOfSimpleGroundRulesQuery because distrPrOverGroundings = false in the grounding of the</span>
  <span class="cmt">// probabilistic rule.</span>
  printAdHocQueryResults = <span class="kw">true</span>,
  printAnswers = <span class="kw">true</span>)</pre><h4>Further examples can be found in the source code of <a href="../userAPItests/APITests.html" name="userAPItests.APITests" id="userAPItests.APITests" class="extype">userAPItests.APITests</a></h4></div><dl class="paramcmts block"><dt class="param">groundSymbolicASPRules</dt><dd class="cmt"><p>Set of ground rules. If backgroundProgramAspifOpt is defined, the symbolicASPRules added to the rules obtained by parsing the string in backgroundProgramAspifOpt</p></dd><dt class="param">backgroundProgramAspifOpt</dt><dd class="cmt"><p>Aspif format with optional costs and parameter specs</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="SymbolicASPRule.html" name="input.SymbolicASPRule" id="input.SymbolicASPRule" class="extype">input.SymbolicASPRule</a>, <a href="GroundSymbolicASPRule.html" name="input.GroundSymbolicASPRule" id="input.GroundSymbolicASPRule" class="extype">input.GroundSymbolicASPRule</a>, <a href="../sharedDefs/index.html" name="sharedDefs" id="sharedDefs" class="extype">sharedDefs</a>, <span name="diffSAT#queryAndPrintSolverResult(boolean," class="extype">boolean, solving.SamplingResult, scala.Option, scala.collection.immutable.Seq, scala.collection.immutable.Seq, scala.collection.immutable.Seq, scala.collection.immutable.Seq, boolean, boolean)</span></p></span></dd></dl></div></li><li class="indented0 " name="input.ProbabilisticBooleanClause" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ProbabilisticBooleanClauseextendsClausewithProductwithSerializable"></a><a id="ProbabilisticBooleanClause:ProbabilisticBooleanClause"></a> <span class="permalink"><a href="../input/ProbabilisticBooleanClause.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="ProbabilisticBooleanClause.html" title="A disjunctive set of literals, annotated with a probability (soft clause)."><span class="name">ProbabilisticBooleanClause</span></a><span class="params">(<span name="literals">literals: <span name="scala.Predef.Set" class="extype">Set</span>[<a href="BooleanLiteral.html" name="input.BooleanLiteral" id="input.BooleanLiteral" class="extype">BooleanLiteral</a>]</span>, <span name="probability">probability: <span name="scala.Double" class="extype">Double</span></span>)</span><span class="result"> extends <a href="Clause.html" name="input.Clause" id="input.Clause" class="extype">Clause</a> with <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">A disjunctive set of literals, annotated with a probability (soft clause).</p><div class="fullcomment"><div class="comment cmt"><p>A disjunctive set of literals, annotated with a probability (soft clause).
Observe that every probabilistic clause causes delSAT to introduce a new auxiliary propositional variable
</p></div></div></li><li class="indented0 " name="input.SolverParametersOverlay" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SolverParametersOverlayextendsProductwithSerializable"></a><a id="SolverParametersOverlay:SolverParametersOverlay"></a> <span class="permalink"><a href="../input/SolverParametersOverlay.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="SolverParametersOverlay.html" title="Solver and sampling settings."><span class="name">SolverParametersOverlay</span></a><span class="params">(<span name="noOfModels">noOfModels: <span name="scala.Int" class="extype">Int</span></span>, <span name="noOfSecondaryModels">noOfSecondaryModels: <span name="scala.Int" class="extype">Int</span></span>, <span name="offHeapGarbageCollectionModeR">offHeapGarbageCollectionModeR: <span name="scala.Int" class="extype">Int</span></span>, <span name="thresholdOpt">thresholdOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>]</span>, <span name="assureMSE">assureMSE: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="showauxInSATmode">showauxInSATmode: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="advancedSolverArgs">advancedSolverArgs: <span name="scala.collection.mutable.HashMap" class="extype">HashMap</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Int" class="extype">Int</span>), <span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">mutable.HashMap()</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Solver and sampling settings.</p><div class="fullcomment"><div class="comment cmt"><p>Solver and sampling settings. For advancedSolverArgs and use, see <a href="../sharedDefs/index.html" name="sharedDefs" id="sharedDefs" class="extype">sharedDefs</a>
</p></div><dl class="paramcmts block"><dt class="param">noOfModels</dt><dd class="cmt"><p>-1: sample until accuracy threshold (thresholdOpt) has been reached</p></dd><dt class="param">noOfSecondaryModels</dt><dd class="cmt"><p>sample n models uniformly from the original sample</p></dd><dt class="param">assureMSE</dt><dd class="cmt"><p>guarantees that the cost functions are in MSE form (see README.md), enables certain performance optimizations</p></dd><dt class="param">advancedSolverArgs</dt><dd class="cmt"><p>See <a href="../sharedDefs/index.html" name="sharedDefs" id="sharedDefs" class="extype">sharedDefs</a></p></dd></dl></div></li><li class="indented0 " name="input.SymbolicASPRule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SymbolicASPRuleextendsProductwithSerializable"></a><a id="SymbolicASPRule:SymbolicASPRule"></a> <span class="permalink"><a href="../input/SymbolicASPRule.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">case class</span></span> <span class="symbol"><a href="SymbolicASPRule.html" title="Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~."><span class="name">SymbolicASPRule</span></a><span class="params">(<span name="headLiterals">headLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="bodyLiterals">bodyLiterals: <span name="scala.collection.Set" class="extype">Set</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>] = <span class="symbol">Set()</span></span>, <span name="choiceHeadOpt">choiceHeadOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>]] = <span class="symbol">None</span></span>, <span name="weightBodySymbolicOpt">weightBodySymbolicOpt: <span name="scala.Option" class="extype">Option</span>[(<span name="scala.Int" class="extype">Int</span>, <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Int" class="extype">Int</span>, <a href="../aspIOutils/index.html#Pred=String" name="aspIOutils.Pred" id="aspIOutils.Pred" class="extmbr">Pred</a>)])] = <span class="symbol">None</span></span>, <span name="probabilityOpt">probabilityOpt: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Double" class="extype">Double</span>] = <span class="symbol">None</span></span>, <span name="variableBindings">variableBindings: <span name="scala.Seq" class="extype">Seq</span>[(<span name="scala.Predef.String" class="extype">String</span>, <span name="scala.Predef.String" class="extype">String</span>)] = <span class="symbol">Seq()</span></span>, <span name="domainAtoms">domainAtoms: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Predef.String" class="extype">String</span>] = <span class="symbol">Seq()</span></span>, <span name="distrPrOverGroundings">distrPrOverGroundings: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="result"> extends <span name="scala.Product" class="extype">Product</span> with <span name="scala.Serializable" class="extype">Serializable</span></span></span><p class="shortcomment cmt">Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~.</p><div class="fullcomment"><div class="comment cmt"><p>Allows to represent all fundamental rule types in Answer Set Programming except weak rules :~.
Additionally, it supports probabilistic rules (rules with a probabilistic weight).
More complex ASP rule types can be created as combinations or desugarings using these basic types, see, e.g., Lifschitz, Turner: Nested Expressions in Logic Programs, 1999.
This data type fully supports ground rules but also has limited support for non-ground rules (for more advanced grounding
needs, it is recommended to use diff-SAT with an aspif file produced from the non-ground answer set program with a tool such as clingo).</p><p>This class also provides some support for non-ground rules, using parameters variableBindings and domainAtoms.
The rule can be grounded by calling <a href="SymbolicASPRule.html#genGroundInstances:Seq[input.GroundSymbolicASPRule]" name="input.SymbolicASPRule#genGroundInstances" id="input.SymbolicASPRule#genGroundInstances" class="extmbr">input.SymbolicASPRule.genGroundInstances</a>.</p><p>However, for more complex grounding requirements, the answer set program should be translated into aspif format before calling diff-SAT,
using, e.g., clingo.</p><p>Complete examples can be found in <a href="ProbabilisticAnswerSetProgram.html" name="input.ProbabilisticAnswerSetProgram" id="input.ProbabilisticAnswerSetProgram" class="extype">input.ProbabilisticAnswerSetProgram</a> and <a href="../userAPItests/APITests.html" name="userAPItests.APITests" id="userAPItests.APITests" class="extype">userAPItests.APITests</a></p><h4>Default and classical negation</h4><p>To represent a classically ("strong") negated atom a, write -p(a). Allowed in head and body literals. "--p(a)" is not allowed.
To represent default negation in head or body literals, use prefix "not" (e.g., "not p(a)").
Double negation ("not not ") is also allowed, both in head and body literals. Triple negation ("not not not") is not supported.</p><p>Redundant whitespace in literals is not allowed. There must be exactly one space character after a "not" and there
mustn't be any whitespaces in literals except to separate "not".
E.g., "not f(X)" is ok, "  not  f ( X) " is invalid.</p><p>Supported rule types:</p><h4>Integrity constraints</h4><p>These are simply rules where the head is the empty set.</p><h4>"Weight rules" (ASP terminology. Unrelated to rules with probabilistic weights!)</h4><p>Instead of bodyLiterals there can be a weightBodySymbolicOpt in the form of Some(lowerBound, Seq((weight1, literal1), ..., (weightN, literalN)))
literal can here be "atom" or "not atom" (but not "not not atom"). Observe that more complex weight rules (e.g.,
with upper bound) can be desugared into multiple more basic rules.
If weightBodySymbolicOpt is defined, bodyLiterals must be empty (but rules with both weight aggregates and plain literals can
be created as combinations of more basic rules).</p><h4>Choice rules</h4><p>Instead of headLiterals, choiceHeadOpt can be present in form of Some(Seq(literal1, ..., literalN)), where
each literal can here be an "atom" (but not "not atom" or "not not atom"). Again, more complex rules (such as choice in bodies)
can be expressed as combinations of simpler rules.
Choice rules are often preferable in terms of complexity over disjunctions (i.e., more than one literal) in the head,
but observe that their semantics is different.
If choiceHeadOpt is defined, headLiterals must be empty.</p><h4>Probabilistic rules</h4><p>To express probabilistic facts, use special predicates _pr_ and _cost_ (must be facts, i.e., in head, with empty body).
E.g., "_pr_(heads(coin), 5000)" or  "_cost_(1 - f(coin))".</p><p>To attach a probability to an entire normal rule, you can use probabilityOpt. In this case, the rule must be normal, i.e,
have exactly one head literal which is positive and double negation or a weight body in the body aren't allowed.</p><p>A probability is represented as a double number w, 0&lt;=w&lt;=1.</p><p>Probabilistic rules don't have to be probabilistically independent from each other.</p><p>If the probabilityOpt=Some(-1), the probability is unknown (informally meaning 'rule v not rule', i.e., a
so-called _spanning rule_ [Nickles,Mileo 2015]).</p><h4>Basic grounding</h4><p>There is limited support for rule grounding (for a more powerful approach to grounding, use clingo/gringo or some
other modern ASP grounder to generate an aspif file which you can then use directly with diff-SAT):</p><p>Grounding is performed if variableBindings and/or variableDomains are provided.</p><p>variableBindings are processed linearly. E.g., rule r(X,Y) :- q(X), p(Y) with variableBindings Seq((X,"a"),(Y,"b"),(X,"c"))
results in a single ground rule r(a,b) :- q(a), p(b), because the second binding of X is ignored. To explore
all combinations, use something like concurrentBindings.flatMap(bindings -&gt; SymbolicASPRule(...,bindings,...))</p><p>In contrast to variableBindings, domainAtoms are processed by using all possible combinations.
E.g., r(X,Y) :- q(X), p(Y) with domainAtoms Seq("q(a)", "p(b)", "q(c)") results in two ground rules
r(a,b) :- q(a), p(b) and r(c,b) :- q(c), p(b)</p><p>variableBindings are processed before domainAtoms, so if any variable is already bound by variableBindings,
it cannot be re-bound by any domainAtoms.</p><p>domainAtoms (as a parameter of SymbolicASPRule) are not necessarily actually facts (in the logical sense) and they are
not automatically added as literals to the rule. If you want that, you need to add those "facts" explictly to
the bodyLiterals or make them actual facts as rules of their own.</p><p>Approaches (outside the scope of diff-SAT) to obtain domainAtoms could be, e.g., to deduce them as extension from given
ground rules where the involved predicates don't recursively depend on each other (as in lparse 1.0), or - less powerful -
to simply use all given ground facts (ground rules with empty body), or to use ground atoms in the body of the non-ground rule.</p><p>If a probability w is provided for a non-ground normal rule using probabilityOpt, it refers either to the conjunction of the
ground rules generated from the non-ground rule or to each individual ground rule, depending on distrPrOverGroundings.
E.g., with distrPrOverGroundings=false, Pr[p(X):-q(Y)] = w is equivalent to Pr[(p(a):-q(b)) <sup> (p(c):-q(a)) </sup> ...] = w,
if the ground instances of p(X):-q(Y) are p(a):-q(b), p(c):-q(a), ...
Whereas with distrPrOverGroundings=true, Pr[p(X):-q(Y)] = w is equivalent to Pr[p(a):-q(b)]=w <sup> Pr[p(c):-q(a)]=w </sup> ...</p><p>ASP variables are words consisting of characters and digits which start with an uppercase letter.
Variables can occur in any literals in the head and/or body.</p><p>Observe that gringo-style anonymous variables (_) or character ' in variables are not allowed here (but such variables
can be used when using clingo/gringo output with diff-SAT).</p><p>Variables in terms are recognized up to parantheses nesting level three.</p><p>diff-SAT doesn't distinguish between the case that a variable occurs in the head and the case it occurs in the body.
</p></div><dl class="paramcmts block"><dt class="param">headLiterals</dt><dd class="cmt"><p>A disjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">bodyLiterals</dt><dd class="cmt"><p>A conjunction of positive or negative or double negative or classical-negative literals (can be empty)</p></dd><dt class="param">choiceHeadOpt</dt><dd class="cmt"><p>See above</p></dd><dt class="param">weightBodySymbolicOpt</dt><dd class="cmt"><p>See above (NB: the term "weight" here is ASP terminology and unrelated to probabilistic weights!)</p></dd><dt class="param">probabilityOpt</dt><dd class="cmt"><p>An optional double value 0 &lt;= p &lt;= 1 or -1 (see above)</p></dd><dt class="param">variableBindings</dt><dd class="cmt"><p>A list containing variable names (words starting with an uppercase letter) paired with ground terms.
                             For example, Seq(("X", "a1"), ("X", "a2"), ("Y", "b1"), ...).
                             Alternatively or additioally, domainAtoms can be provided to ground rules.</p></dd><dt class="param">domainAtoms</dt><dd class="cmt"><p>A list of ground atoms, e.g., "fac1(a,b)", "fac1(c,d)", "fac2(a)", ...).
                             Like variableBindings, they are used to ground rules (by determining further variable bindings).
                             NB: Ground facts listed here serve only to instantiate variables, they do not automatically become
                             body literals or even global facts. If you wish to add them, e.g., to the rule body, you need to append them
                             to bodyLiterals.
                             NB: redundant whitespace is not allowed in domain atoms and rule literals</p></dd><dt class="param">distrPrOverGroundings</dt><dd class="cmt"><p>If true (default), the probability probabilityOpt (if defined) is assumed to be the probability of each individual
                             ground instances of the rule (corresponding to weight syntax <span name="pr" class="extype">pr</span> in PrASP).
                             If false, the given probability (probabilityOpt, if defined) is the probability of the
                             entire conjunction of all ground instances of this rule (corresponding to weight syntax [pr] in PrASP).
                             Only relevant if there are variables in the literals, variableDomains is not empty, and probabilityOpt is defined.</p></dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="input.AspifPlainParser" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="AspifPlainParser"></a><a id="AspifPlainParser:AspifPlainParser"></a> <span class="permalink"><a href="../input/AspifPlainParser$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="AspifPlainParser$.html" title="Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules."><span class="name">AspifPlainParser</span></a></span><p class="shortcomment cmt">Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parser for a subset of the ASP Intermediate Format (aspif), enhanced with support for probabilistic rules.
Not a general-purpose aspif parser; designed for use in delSAT only.</p><p>Probabilistic rules have the form
1000 p 1 0 1 h B
(p either being -1 (undefined probability) or a probability 0&lt;=p&lt;=1. h being a single atom (the only literal in the head)
and B being a normal rule body). If p = -1, only the spanning formula [Nickles, Mileo 2015] is being generated but no _pr_ fact,
which informally means "rule v not rule".</p><p>Observe that the above isn't the only way to specify probabilities with delSAT - see README.md for other supported input formats.</p><p>For a description of the aspif file format see Appendix A in "A Tutorial on Hybrid Answer Set Solving with clingo",
https://link.springer.com/chapter/10.1007/978-3-319-61033-7_6, Appendix A.</p><p>All aspif 1 rule types are supported (including choice, disjunctions in head, weight bodies), however statements
of type &gt;= 2 (e.g.., minimize statements or #external) are currently not implemented. Output statements (#show) are partially supported.</p><p>If some aspif file still cannot be processed it is recommended to try with a preprocessor such as Clingo 5 using options
--trans-ext=all --pre=aspif) or lp2normal to translate extended rules. But observe that delSAT cannot be used for finding
an optimal model (e.g., using ~| or #minimize).
</p></div></div></li><li class="indented0 " name="input.DIMACPlainSparser" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="DIMACPlainSparser"></a><a id="DIMACPlainSparser:DIMACPlainSparser"></a> <span class="permalink"><a href="../input/DIMACPlainSparser$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="DIMACPlainSparser$.html" title="Parser for DIMACS-CNF and PCNF (probabilistic CNF)."><span class="name">DIMACPlainSparser</span></a></span><p class="shortcomment cmt">Parser for DIMACS-CNF and PCNF (probabilistic CNF).</p><div class="fullcomment"><div class="comment cmt"><p>Parser for DIMACS-CNF and PCNF (probabilistic CNF). !! Not a general-purpose DIMACS-CNF parser - designed for use within diff-SAT only! Work in progress.
</p></div></div></li><li class="indented0 " name="input.ParseOptimizationTerms" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ParseOptimizationTerms"></a><a id="ParseOptimizationTerms:ParseOptimizationTerms"></a> <span class="permalink"><a href="../input/ParseOptimizationTerms$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ParseOptimizationTerms$.html" title=""><span class="name">ParseOptimizationTerms</span></a></span></li><li class="indented0 " name="input.diffSAT" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="diffSAT"></a><a id="diffSAT:diffSAT"></a> <span class="permalink"><a href="../input/diffSAT$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="diffSAT$.html" title=""><span class="name">diffSAT</span></a><span class="result"> extends <a href="../userAPItests/APITests.html" name="userAPItests.APITests" id="userAPItests.APITests" class="extype">APITests</a></span></span><p class="shortcomment cmt"></p></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
